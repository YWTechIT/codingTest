### floyd_warshall_algorithm
>1. `dijkstra`: ν• μ§€μ μ—μ„ λ‹¤λ¥Έ νΉμ • μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅λ¥Ό κµ¬ν•λ” κ²½μ°
>2. `floyd_warshall`: λ¨λ“  μ§€μ μ—μ„ λ¨λ“  μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅λ¥Ό λ¨λ‘ κµ¬ν•λ” κ²½μ°

---

ex) 2λ² λ…Έλ“μ μ ν™”μ‹μ„ κµ¬ν•  λ•, `λ€κ°μ„  0`, `2ν–‰ 2μ—΄μ κ°’μ€ κµ¬ν•μ§€ μ•μ•„λ„ λλ‹¤.`
μ¦‰, [1, 2, 3, 4]μ λ…Έλ“ μ¤‘ 2λ¥Ό μ μ™Έν• λ‚λ¨Έμ§€ [1, 3, 4]λ…Έλ“ μ¤‘ 2κ°μ λ…Έλ“λ¥Ό λ½‘λ” κ²½μ°
`[1, 3] [1, 4] [3, 1] [3, 4] [4, 1] [4, 3]`μ κ²½μ°μ μλ§ κµ¬ν•λ©΄ λλ‹¤.

λ‚λ¨Έμ§€ λ…Έλ“μ κ²½μ°μ μλ¥Ό κµ¬ν• λ•λ„ λ™μΌν•λ‹¤.

```python
import itertools

data = [1, 3, 4]

for i in itertools.permutations(data, 2):
    print(list(i), end=' ')
π‘‰π½ [1, 3] [1, 4] [3, 1] [3, 4] [4, 1] [4, 3]
```

| μ¶λ° / λ„μ°© | 1 | 2 | 3 | 4 |
| :----: | :----: | :----: | :----: | :----: | 
| 1 | 0 | 0 | * | * |
| 2 | 0 | 0 | 0 | 0 |
| 3 | * | 0 | 0 | * |
| 4 | * | 0 | * | 0 |

---

λ§¤λ² <span style='color:blue'>λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘ μµλ‹¨ κ±°λ¦¬λ¥Ό κ°–λ” λ…Έλ“λ¥Ό μ°Ύμ„ ν•„μ”κ°€ μ—†λ‹¤.</span>

λ…Έλ“μ κ°μκ°€ `N`κ°μΌ λ•, μ•κ³ λ¦¬μ¦μƒμΌλ΅ `N`λ²μ λ‹¨κ³„λ¥Ό μν–‰ν•λ©°, λ‹¨κ³„λ§λ‹¤ `O(N^2)`μ μ—°μ‚°μ„ ν†µν•΄ `ν„μ¬ κ±°μ³κ°€λ”` λ¨λ“ κ²½λ΅λ¥Ό κ³ λ ¤ν•λ‹¤. λ”°λΌμ„, ν”λ΅μ΄λ“ μ›μ… μ•κ³ λ¦¬μ¦μ μ΄ μ‹κ°„ λ³µμ΅λ„λ” `O(N^3)`μ΄λ‹¤.

μ ν™”μ‹μ— λ§κ² 2μ°¨μ› λ¦¬μ¤νΈλ¥Ό κ°±μ‹ ν•κΈ° λ•λ¬Έμ— `dynamic_programming`μ΄λΌκ³ λ„ λ¶€λ¥Έλ‹¤.

> D(ab) = min(D(ab), D(ak) + D(kb))

```python
'''
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
'''

INF = int(1e9)

# λ…Έλ“, κ°„μ„  μ…λ ¥λ°›κΈ°
n, m = int(input())

# 2μ°¨μ› λ¦¬μ¤νΈλ¥Ό λ§λ“¤κ³  graphμ λ¨λ“  κ°’μ€ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
graph = [[INF] * (n+1) for _ i in range(n+1)]

# μκΈ° μμ‹ μΌλ΅ κ°€λ” κ°’μ€ 0μΌλ΅ μ΄κΈ°ν™”
for a in range(1, n+1):
    for b in range(1, n+1):
        if a == b:
            graph[a][b] = 0

# κ°„μ„ μ— λ€ν• μ…λ ¥ μ •λ³΄ μ €μ¥
for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a][b] = c

# μ ν™”μ‹ μ…λ ¥
for k in range(1, n+1):
    for a in range(1, n+1):
        for b in range(1, n+1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# κ²°κ³Ό μ¶λ ¥
for a in range(1, n+1):
    for b in range(1, n+1):
        if graph[a][b] == INF:
            print('INFINITY', end= ' ')
        else:
            print(graph[a][b], end=' ')

π‘‰π½
0 4 8 6 
3 0 7 9 
5 9 0 4 
7 11 2 0
```

---

### [ λ¬Έμ  1 ] λ―Έλλ„μ‹
λ°©λ¬Έ νλ§¤μ› Aλ” ν„μ¬ 1λ²νμ‚¬μ— μ„μΉν•΄ μμΌλ©°, Xλ² νμ‚¬μ— λ°©λ¬Έν•΄ λ¬Όκ±΄μ„ νλ§¤ν•κ³ μ ν•λ‹¤.

>1. λ‚μ¤‘μ— μ…λ ¥λ°›μ„ μλ” λ”°λ΅ μ„ μ–Έν•΄μ£Όμ.
>2. 1λ²λ…Έλ“μ—μ„ Xλ¥Ό κ±°μ³ Kλ΅ κ°€λ” μµλ‹¨κ±°λ¦¬ κ³„μ‚°λ²•: 1λ²μ—μ„ XκΉμ§€μ μµλ‹¨κ±°λ¦¬ + Xλ¶€ν„° KκΉμ§€μ μµλ‹¨κ±°λ¦¬
`distance = graph[1][k] + graph[k][x]`

```python
'''
5 7
1 2
1 3
1 4
2 4
3 4
3 5
4 5
4 5

4 2
1 3
2 4
3 4
'''

INF = int(1e9)

n, m = map(int, input().split())

graph = [[INF] * (n+1) for _ in range(n+1)]

for a in range(1, n+1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

for i in range(m):
    a, b = map(int, input().split())
    graph[a][b] = 1
    graph[b][a] = 1


x, k = map(int, input().split())

for k in range(1, n+1):
    for a in range(1, n+1):
        for b in range(1, n+1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])


distance = graph[1][k] + graph[k][x]

if distance >= INF:
    print(-1)
else:
    print(distance)

π‘‰π½ 3
π‘‰π½ -1
```
