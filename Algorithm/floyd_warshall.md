### floyd_warshall_algorithm
>1. `dijkstra`: í•œ ì§€ì ì—ì„œ ë‹¤ë¥¸ íŠ¹ì • ì§€ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ê²½ìš°
>2. `floyd_warshall`: ëª¨ë“  ì§€ì ì—ì„œ ëª¨ë“  ì§€ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ëª¨ë‘ êµ¬í•˜ëŠ” ê²½ìš°

---

ex) 2ë²ˆ ë…¸ë“œì˜ ì í™”ì‹ì„ êµ¬í•  ë•Œ, `ëŒ€ê°ì„  0`, `2í–‰ 2ì—´ì˜ ê°’ì€ êµ¬í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.`
ì¦‰, [1, 2, 3, 4]ì˜ ë…¸ë“œ ì¤‘ 2ë¥¼ ì œì™¸í•œ ë‚˜ë¨¸ì§€ [1, 3, 4]ë…¸ë“œ ì¤‘ 2ê°œì˜ ë…¸ë“œë¥¼ ë½‘ëŠ” ê²½ìš°
`[1, 3] [1, 4] [3, 1] [3, 4] [4, 1] [4, 3]`ì˜ ê²½ìš°ì˜ ìˆ˜ë§Œ êµ¬í•˜ë©´ ëœë‹¤.

ë‚˜ë¨¸ì§€ ë…¸ë“œì˜ ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í• ë•Œë„ ë™ì¼í•˜ë‹¤.

```python
import itertools

data = [1, 3, 4]

for i in itertools.permutations(data, 2):
    print(list(i), end=' ')
ğŸ‘‰ğŸ½ [1, 3] [1, 4] [3, 1] [3, 4] [4, 1] [4, 3]
```

| ì¶œë°œ / ë„ì°© | 1 | 2 | 3 | 4 |
| :----: | :----: | :----: | :----: | :----: | 
| 1 | 0 | 0 | * | * |
| 2 | 0 | 0 | 0 | 0 |
| 3 | * | 0 | 0 | * |
| 4 | * | 0 | * | 0 |

---

ë§¤ë²ˆ <span style='color:blue'>ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê°–ëŠ” ë…¸ë“œë¥¼ ì°¾ì„ í•„ìš”ê°€ ì—†ë‹¤.</span>

ë…¸ë“œì˜ ê°œìˆ˜ê°€ `N`ê°œì¼ ë•Œ, ì•Œê³ ë¦¬ì¦˜ìƒìœ¼ë¡œ `N`ë²ˆì˜ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•˜ë©°, ë‹¨ê³„ë§ˆë‹¤ `O(N^2)`ì˜ ì—°ì‚°ì„ í†µí•´ `í˜„ì¬ ê±°ì³ê°€ëŠ”` ëª¨ë“ ê²½ë¡œë¥¼ ê³ ë ¤í•œë‹¤. ë”°ë¼ì„œ, í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ì˜ ì´ ì‹œê°„ ë³µì¡ë„ëŠ” `O(N^3)`ì´ë‹¤.

ì í™”ì‹ì— ë§ê²Œ 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ë¥¼ ê°±ì‹ í•˜ê¸° ë•Œë¬¸ì— `dynamic_programming`ì´ë¼ê³ ë„ ë¶€ë¥¸ë‹¤.

> D(ab) = min(D(ab), D(ak) + D(kb))

```python
'''
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
'''

INF = int(1e9)

# ë…¸ë“œ, ê°„ì„  ì…ë ¥ë°›ê¸°
n, m = int(input())

# 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³  graphì˜ ëª¨ë“  ê°’ì€ ë¬´í•œìœ¼ë¡œ ì´ˆê¸°í™”
graph = [[INF] * (n+1) for _ i in range(n+1)]

# ìê¸° ìì‹ ìœ¼ë¡œ ê°€ëŠ” ê°’ì€ 0ìœ¼ë¡œ ì´ˆê¸°í™”
for a in range(1, n+1):
    for b in range(1, n+1):
        if a == b:
            graph[a][b] = 0

# ê°„ì„ ì— ëŒ€í•œ ì…ë ¥ ì •ë³´ ì €ì¥
for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a][b] = c

# ì í™”ì‹ ì…ë ¥
for k in range(1, n+1):
    for a in range(1, n+1):
        for b in range(1, n+1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# ê²°ê³¼ ì¶œë ¥
for a in range(1, n+1):
    for b in range(1, n+1):
        if graph[a][b] == INF:
            print('INFINITY', end= ' ')
        else:
            print(graph[a][b], end=' ')

ğŸ‘‰ğŸ½
0 4 8 6 
3 0 7 9 
5 9 0 4 
7 11 2 0
````

