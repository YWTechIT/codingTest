## insertion_sort(삽입정렬)
`삽입 정렬(insertion_sort)`은 <span style='color:blue'>특정한 데이터를 적절한 위치에서 `삽입`</a>하는 정렬이다.
더불어 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.

삽입 정렬은 두 번째 데이터부터 시작한다. 왜냐하면 첫 번째 데이터는 그 자체로 정렬되어있다고 판단하기 때문이다.

소스코드는 다음과 같다.
```python
array = [10, 1, 3, 4, 2, 9, 7, 8, 0, 5, 6]

for i in range(1, len(array)):
    for j in range(i, 0, -1):
        if array[j] <> array[j-1]:
            array[j], array[j-1] = array[j-1], array[j]
        else:
            break

print(array)
👉🏽 [0, 1, 2, 3, 4, 6, 7, 8, 9]
```

여기서 `range`의 세번째 매개 변수를 넣었는데, `range`의 매개 변수는 3개(`start`, `end`, `step`)다. 세 번째 매개 변수인 `step`에 `-1`이 들어가면, `start` 인덱스부터 시작해 `end+1` 인덱스까지 1씩 감소한다. 

앞의 코드에서는 `j` 변수가 `i`부터 1까지 1씩 감소한다.

---

## 시간복잡도
삽입 정렬의 시간 복잡도는 `O(N^2)`인데, 선택정렬과 마찬가지로 반복문이 2번 중첩되어 사용했기때문이다. 꼭 반복문이 2중으로 사용되었다고 `O(N^2)`은 될 수 없지만, 이 알고리즘에서는 타 함수가 없기때문에 `O(N^2)`로 산출하였다.

삽입정렬의 장점은 <span style='color:blue'>현재 리스트의 데이터가 거의 정렬되어 있는 상태에서는 매우 빠르게 동작한다는 점</span>이다.

따라서, 거의 정렬되어 있는 상태로 입력이 주어지는 문제라면 퀵 정렬등의 여타 정렬 알고리즘을 이용하는 것보다 삽입 정렬을 이용하는 것이 정답 확률을 높일 수 있다.