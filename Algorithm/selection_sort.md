## selection_sort(선택정렬)
`선택 정렬(selection_sort)`은 <span style='color:blue'>가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정</a>이다

가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다 보면, 전체 데이터의 정렬이 이루어진다.

수행과정은 다음과 같다.
>1. 초기 단계에서 모든 데이터가 정렬되어있지 않으므로, 전체 데이터 중 가장 작은 데이터를 선택한다. 
>2. 첫 번째를 제외하고 이후 데이터 중 가장 작은 데이터를 선택해 처리되지 않은 데이터 중 가장 앞에있는 데이터와 바꾼다.
>3. 정렬된 데이터를 제외하고 정렬되지 않은 데이터 중 가장 작은 데이터를 선택하고 처리되지 않은 데이터 중 가장 앞에 있는 데이터와 바꾼다.
>4. 가장 작은 데이터를 앞으로 보내는 과정을 모두 반복한 상태의 마지막 데이터는 가만히 두어도 이미 정렬된 상태이다. 따라서 정렬을 마칠 수 있다. `n-1`만큼 반복하면 된다.

```python
array = [10, 1, 3, 4, 2, 9, 7, 8, 0, 5, 6]

for i in range(len(array)):
    min_index = i
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array # 스와핑
    [min_index], array[i]

print(array)
👉🏽 [0, 1, 2, 3, 4, 6, 7, 8, 9]
```

중간에 `스와프(swap)` 개념이 등장했다. 
이는 특정한 리스트가 주어졌을 때, 두 변수의 위치를 변경하는 작업을 의미한다. 
다른 프로그래밍 언어와 다르게(임시 저장용 변수 생성 후 두 원소의 값 변경) 파이썬에서는 다음처럼 간단하게 리스트 내 두 원소의 위치를 변경할 수 있다. 

```python
data = [1, 2]
data[0], data[1] = data[1], data[0]

print(data)
👉🏽 [2, 1]
```

---

## 시간복잡도
선택정렬은 `N-1`번 만큼 가장 작은 수를 찾아 맨 앞으로 보내야 한다. 또한, 매번 가장 작은 수를 찾기 위해서 비교 연산이 필요하다. 

구현 방식에 따라 사소한 오차는 있을 수 있지만, 앞쪽의 순서대로 구현했을 경우 연산 횟수는 `N + (N-1) + (N-2) + ... + 2`로 볼 수 있다. 

따라서, 근사치 `N x (N + 1) / 2`번의 연산을 수행한다고 했을 때, 가장 큰 수를 꺼내면 시간복잡도는 `O(N^2)`이 된다.

선택정렬은 <span style='color:blue'>정렬해야 할 데이터의 개수가 10,000개 이상이면 정렬 속도가 급격히 느려지므로 10,000개 이하</span>일때 가급적 사용하도록 하자.

다음의 표를 참고하여 정렬 알고리즘 별 소요시간을 살펴보자.

| 데이터의 개수(N) | 선택 정렬 | 퀵 정렬 | 기본 정렬 라이브러리 |
| :----: | :------: | :------: | :------: |
| N = 100 | 0.0123초 | 0.00156초 | 0.00000753초
| N = 1,000 | 0.354초 | 0.00343초 | 0.0000365초
| N = 10,000 | 15.475초 | 0.0312초 | 0.000248초 |