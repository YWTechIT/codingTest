## 5장 리스트, 딕셔너리

### 📍 list(리스트)
리스트는 말 그대로 순서대로 저장하는 시퀀스(sequence)이자, 변경 가능한 목록(mutable list)을 말한다. 입력 순서가 유지되며, 내부적으로는 동적 배열로 구현되어 있다. 리스트의 다양한 기능들의 시간복잡도는 다음과 같다.

> 1. O(1): `append()`, `pop()`, `access(a[i])`, `len(a)`
> 2. O(N): `min/max`, `a.count()`, `a[i:j]`, `del a[i]`, `a.reverse()`, `a.index`, ` a.pop(0)`, `elem in a`
> 3. O(NlogN): `a.sort()`

파이썬의 리스트는 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 듯한 형태를 띠며, 실제로 리스르를 잘 사용하기만 하더라도 배열과 연결 리스트가 모두 필요없을 정도로 강력하다. 때문에 파이썬은 원시 타입 자료형은 제공하지도 않는다.

파이썬은 모든것이 객체며, 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하고 있으며, 그 덕분에 강력한 기능을 자랑한다. 또, 리스트에서 제각각의 자료형을 통합해서 저장 할 수 있다. 그러나, 각 자료형의 크기가 각각 다르기 대문에 이들을 연속된 메모리에 할당하는것은 불가능하고 대신 각각의 객체에 대한 참조로 구현될 수 밖에 없다. 

심지어 인덱스를 조회할때도 값을 일일이 살펴봐야 하는등 추가적인 작업이 필요하기 때문에 속도 면에서도 훨씬 더 불리하다. 이처럼 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 참조를 택했으며, 이로 인해 부득이하게 속도를 희생한 측면이 있다.

### 📍 dictionary(딕셔너리)
파이썬의 딕셔너리는 키/값 구조로 이뤄진 딕셔너리를 말한다. 내부적으로는 해시 테이블로 구현되어 있다. 파이썬 딕셔너리의 주요 특징은 해시 할 수만 있다면 숫자뿐만 아니라, 문자, 집합까지 불변 객체를 모두 키로 사용할 수 있다. 무엇보다 해시 테이블은 다양한 타입을 키로 지원하면서도 입력과 조회 모두 O(1)에 가능하다. 물론 최악의 경우 O(N)이 될 수 있으나, 대부분의 경우 훨씬 더 빨리 실행되며 분할 상황 분석에 따른 시간 복잡도는 O(1)이다.

> O(1): `len(a)`, `a[key]`, `a[key]=value`, `key in a`

또, 주요한 특징으로는 원래 파이썬에서 딕셔너리는 입력 순서가 유지되지 않았다. 마찬가지로 대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다. 파이썬 3.7부터는 내부적으로 인덱스를 이용해 입력순서를 유지하도록 개선됐으나, 3.6이하 버전을 사용하는곳에서는 입력순서가 유지되지 않는다. 코딩테스트를 치룰 때는 입력순서가 유지되지 않는다고 생각하고 문제를 풀자.

1. `defaultdict`: 존재하지 않는 키를 조회할 경우, 에러 메시지를 출력하는 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.
2. `counter`: 아이템 개수를 계산해 딕셔너리로 리턴한다
3. `OrderedDict`: 해시테이블을 이용한 자료형은 입력 순서가 유지되지 않지만, 별도의 객체를 선언할 수 있다.

```python
from collections import OrderedDict, Counter, defaultdict
s = 'mississippi'

# 1. defaultdict
arr = defaultdict(int)

for i in s:
    arr[i] += 1

print(dict(arr))
👉🏽 {'m': 1, 'i': 4, 's': 4, 'p': 2}

# 2. Counter
result = Counter(s)

# 3. OrderedDict
result = orderedDict({'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2})
print(result)
👉🏽 OrderedDict([('banana', 3), ('apple', 4), ('pear', 1), ('orange', 2)])
```
